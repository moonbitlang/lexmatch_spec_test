// Unicode tests - matching Unicode literals, escapes, and ASCII-only classes

///|
test "Unicode - literal CJK match" {
  lexmatch "ä½ å¥½" {
    "ä½ å¥½" => ()
    _ => fail("Should match literal CJK characters")
  }
}

///|
test "Unicode - mixed ASCII and CJK" {
  lexmatch "helloä¸–ç•Œ" {
    ("hello" "ä¸–ç•Œ") => ()
    _ => fail("Should match mixed ASCII and Unicode")
  }
}

///|
test "Unicode - \\u escape BMP" {
  lexmatch "ä½ " {
    "\u4F60" => ()
    _ => fail("Should match U+4F60")
  }
}

///|
test "Unicode - \\u{...} escape non-BMP" {
  lexmatch "ðŸ§ª" {
    "\u{1F9EA}" => ()
    _ => fail("Should match U+1F9EA")
  }
}

///|
test "Unicode - dot matches one codepoint" {
  lexmatch "æ±‰" {
    "." => ()
    _ => fail("Dot should match a Unicode character")
  }
}

///|
test "Unicode - character class literals" {
  lexmatch "ç•Œ" {
    "[ä½ å¥½ç•Œ]" => ()
    _ => fail("Should match Unicode class literal")
  }
  lexmatch "ä½ " {
    "[ç•Œ]" => fail("Should not match non-member")
    _ => ()
  }
}

///|
test "Unicode - capture with rest" {
  lexmatch "ä½ å¥½ä¸–ç•Œ" {
    ("ä½ å¥½" as greeting, rest) =>
      if greeting.to_string() == "ä½ å¥½" && rest.to_string() == "ä¸–ç•Œ" {
        ()
      } else {
        fail("Should capture greeting and rest")
      }
    _ => fail("Should match")
  }
}

///|
test "Unicode - ASCII classes exclude non-ASCII" {
  lexmatch "Ã©" {
    "[[:alpha:]]" => fail("ASCII alpha should not match Ã©")
    _ => ()
  }
  lexmatch "ä½ " {
    "[[:word:]]" => fail("ASCII word should not match CJK")
    _ => ()
  }
}

///|
test "Unicode - [[:ascii:]] only matches ASCII" {
  lexmatch "A" {
    "[[:ascii:]]" => ()
    _ => fail("Should match ASCII letter")
  }
  lexmatch "ðŸ˜€" {
    "[[:ascii:]]" => fail("Should not match emoji")
    _ => ()
  }
}
